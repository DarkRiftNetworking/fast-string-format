using System.Linq;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Reflection;
using System.Globalization;

namespace FastStringFormat
{
    public class Compiler
    {
        private const BindingFlags BINDING_FLAGS = BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public;

        public Compiler()
        {
            
        }

        public Func<T, string> Compile<T>(string formatString)
        {
            return Compile<T>(formatString, CultureInfo.CurrentCulture);
        }

        public Func<T, string> Compile<T>(string formatString, IFormatProvider formatProvider)
        {
            if (formatString == null)
                throw new ArgumentNullException(nameof(formatString));

            Expression formatProviderExpression = Expression.Constant(formatProvider);

            List<Segment> segments = ParseSegments(formatString, formatProviderExpression);

            ParameterExpression parameter = Expression.Parameter(typeof(T));

            // Select the best method of forming the string
            // TODO May be faster to nest concat operations up until a certain point before resorting to allocating an array object in the process. Perhaps a user preference?
            Expression formatExpression;
            if (segments.Count == 1)
            {
                formatExpression = segments[0].ToExpression<T>(parameter);
            }
            else if (segments.Count <= 4)
            {
                MethodInfo concatMethodInfo = typeof(string).GetMethod("Concat", Enumerable.Repeat(typeof(string), segments.Count).ToArray());
                IEnumerable<Expression> parameterExpressions = segments.Select(s => s.ToExpression<T>(parameter));

                formatExpression = Expression.Call(null, concatMethodInfo, parameterExpressions);
            }
            else
            {
                MethodInfo concatMethodInfo = typeof(string).GetMethod("Concat", new Type[] { typeof(string[]) });
                IEnumerable<Expression> parameterExpressions = segments.Select(s => s.ToExpression<T>(parameter));
                Expression parameterExpressionArray = Expression.NewArrayInit(typeof(string), parameterExpressions);

                formatExpression = Expression.Call(null, concatMethodInfo, parameterExpressionArray);
            }
            
            return Expression.Lambda<Func<T, string>>(
                formatExpression,
                "FastStringFormatAutogenerated",
                new ParameterExpression[] { parameter }
            ).Compile();
        }

        private List<Segment> ParseSegments(string formatString, Expression formatProviderExpression)
        {
            int ptr = 0;
            List<Segment> segments = new List<Segment>();
            while (ptr < formatString.Length)
            {
                // Seek to open brace
                int openBraceAt = formatString.IndexOf('{', ptr);
                
                // If there was no open brace we've hit the end of the string
                if (openBraceAt == -1)
                {
                    segments.Add(new TextSegment(formatString.Substring(ptr)));
                    break;
                }

                // Else if there was an open brace then store previous text segment if there was any
                int textSegmentLength = openBraceAt - ptr;
                if (textSegmentLength != 0)
                    segments.Add(new TextSegment(formatString.Substring(ptr, textSegmentLength)));

                // Seek to close brace and colon
                int closeBraceAt = formatString.IndexOf('}', openBraceAt);
                int colonAt = formatString.IndexOf(':', openBraceAt);

                // If a colon was used before the closing brace consume as a formatted param
                if (colonAt != -1 && colonAt < closeBraceAt)
                {
                    string paramSegment = formatString.Substring(openBraceAt + 1, colonAt - openBraceAt - 1);
                    string formatSegment = formatString.Substring(colonAt + 1, closeBraceAt - colonAt - 1);

                    if (paramSegment.Length == 0)
                        throw new FormatStringSyntaxException($"Empty parameter at position {openBraceAt}.");

                    if (formatSegment.Length == 0)
                        throw new FormatStringSyntaxException($"Empty format at position {openBraceAt}.");

                    segments.Add(new FormattedParamSegment(paramSegment, formatSegment, formatProviderExpression));
                    
                    ptr = closeBraceAt + 1;
                    continue;
                }

                // Else if there was no colon just consume the param
                if (closeBraceAt != -1)
                {
                    string paramSegment = formatString.Substring(openBraceAt + 1, closeBraceAt - openBraceAt - 1);
                    
                    if (paramSegment.Length == 0)
                        throw new FormatStringSyntaxException($"Empty parameter at position {openBraceAt}.");
                    
                    segments.Add(new ParamSegment(paramSegment));
                    
                    ptr = closeBraceAt + 1;
                    continue;
                }

                // No matching close brace *brrrpp*
                throw new FormatStringSyntaxException($"Missing '}}' to match '{{' at position {openBraceAt}.");
            }

            return segments;
        }

        internal interface Segment
        {
            Expression ToExpression<T>(ParameterExpression parameter);
        }

        internal class TextSegment : Segment
        {
            private string text;

            public TextSegment(string text)
            {
                this.text = text;
            }

            public Expression ToExpression<T>(ParameterExpression parameter)
            {
                return Expression.Constant(text);
            }
        }
        
        internal class ParamSegment : Segment
        {
            private string param;

            public ParamSegment(string param)
            {
                this.param = param;
            }

            public Expression ToExpression<T>(ParameterExpression parameter)
            {
                MethodInfo getMethod = typeof(T).GetProperty(param, BINDING_FLAGS)?.GetGetMethod();
                if (getMethod == null)
                    throw new FormatStringSyntaxException($"Property '{param}' not found on type '{nameof(T)}'. Does it have a public get accessor?");

                Expression getExpression = Expression.Call(parameter, getMethod);

                if (getMethod.ReturnType == typeof(string))
                {
                    return getExpression;
                }
                else
                {
                    MethodInfo toStringMethod = typeof(T).GetMethod("ToString", new Type[0]);
                    return Expression.Call(getExpression, toStringMethod);
                }
            }
        }

        internal class FormattedParamSegment : Segment
        {
            private string param;
            private string format;

            private Expression formatProviderExpression;

            public FormattedParamSegment(string param, string format, Expression formatProviderExpression)
            {
                this.param = param;
                this.format = format;
                this.formatProviderExpression = formatProviderExpression;
            }

            public Expression ToExpression<T>(ParameterExpression parameter)
            {
                MethodInfo getMethod = typeof(T).GetProperty(param, BINDING_FLAGS)?.GetGetMethod();
                if (getMethod == null)
                    throw new FormatStringSyntaxException($"Property '{param}' not found on type '{nameof(T)}'. Does it have a public get accessor?");

                if (!getMethod.ReturnType.GetInterfaces().Contains(typeof(IFormattable)))
                    throw new FormatStringSyntaxException($"Property '{param}' does not return a type implementing IFormattable hence a format string cannot be applied to it.");

                Expression getExpression = Expression.Call(parameter, getMethod);
                Expression formatExpression = Expression.Constant(format);
                MethodInfo toStringMethod = typeof(IFormattable).GetMethod("ToString", new Type[] { typeof(string), typeof(IFormatProvider) });

                return Expression.Call(getExpression, toStringMethod, formatExpression, formatProviderExpression);
            }
        }
    }
}